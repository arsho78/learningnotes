## Chapter 1 XML概述 ##
XML(Extensible Markup Language, 可扩展标记语言)

一份XML文件至少应满足如下几个要求：

- 整个XML文档有且仅有一个根元素
- 每个元素都由开始标签和结束标签组成，除非使用空元素语法
- 元素与元素之间应该合理嵌套
- 元素的属性必须有属性值

MVC（Model，View，Control 模式，视图，控制器）

## Chapter 2 XML 文档规则 ##

- 格式不良好(malformed)的XML文档：完全没有遵守XML文档基本规则的XML文档
- 格式良好(well-formed)但无效的XML文档：遵守了XML文档基本规则，但没有使用DTD或Schema定义语义约束的XML文档，或者定义了约束但没有遵守语义约束的XML文档
- 有效(valid)的XML文档：遵守了XML文档基本规则，也定义并遵守了DTD和Schema语义约束

### XML文档的整体结构 ###

- 有且仅有一个根元素
	- DOM(Document Object Model)
- 元素必须合理结束
	- 所有开始标签都必须有配对的结束标签
	- 空元素必须严格使用空元素语法: <tagname />
	- XML的语法严格区分大小写
- 元素之间必须合理嵌套
- 元素的属性必须有值
	- 只有在子元素包含的内容完全是字符串的时候才能将子元素改写为属性
	- 所有属性必须有值，且每个属性值必须使用引号引起来，既可以是单引号，也可以是双引号，但必须成对使用
	- 元素的属性是无序不能重复的，相当于set，而子元素是有序可以重复的，相当于list

### XML声明 ###
声明不是必须的，但如果有，必须放在第一行，并且同时指定声明的version属性，encoding属性指定的编码必须和保存文件时使用的编码相同

	<?xml version="1.0" encoding="GB2312" standalone="yes"?>

### XML元素的基本规则 ###
#### 合法的标签名 ####

- 标签名可以由字母，数字，下划线，中划线，冒号和点号组成，但不能以数字，中划线和点号开始
- 标签名不能包含< > , $等符号
- 标签名中尽量不要使用冒号，除非是在使用命名空间
- 标签名不能以任何大小写的“xml”组合开始
- 标签名不能包含空格
- 标签名区分大小写，同一标签的开始签名和结束签名必须一致

#### 空元素 ####
<tagname />

空元素不能包含子元素，也不能包含字符串内容，但可以拥有属性

### 字符数据 ###

**特殊字符的显示**

- 使用实体引用
	- `&lt;` = `<`
	- `&gt;` = `>`
	- `&amp;` = `&`
	- `&apos;` = `'`
	- `&quot;` = `"`
- 使用CDATA标记

	`<![CDATA[文本内容]]>`

### 注释 ###
<!-- 注释字符串 -->

- 注释内可以包含元素和标签
- 不要把注释放在标签内使用
- 声明前不能有注释
- 不能在注释中使用双中划线
- 不能以--->结尾

### 处理指令 ###
    <?处理指令名 处理指令信息?>

### 标签属性的使用 ###

- 元数据（关于数据的数据）才应该存储为属性，而数据本身应该存储为元素
- 属性通常提供不属于数据组成部分的信息，如果信息属于实体本身，则使用子元素来描述
- XML元素的属性必须显示指定属性值，属性值必须由引号引起来
- 同一个XML元素里不能有重名的属性
- XML元素里的属性是无序的

**属性的缺点**

- 无法包含多个值
- 无法描述树状结构
- 不能扩展
- 难以阅读和维护

### 换行处理 ###

- Windows： CR(\r) && LF(\n)
- Unix & XML: LF(\n)
- Mac: CR(\r)

## chapter 3 DTD详解 ##

DTD：Document Type Definition 文档类型定义

- 内部DTD：紧跟在XML声明和处理指令之后，以`<!DOCTYPE`开始，以`]`结束。
- 外部DTD：`<!DODTYPE 根元素名 SYSTEM "外部DTD的URI">`。
- 公用DTD：`<!DODTYPE 根元素名 PUBLIC "DTD的标识名" "公用DTD的URI">`

DTD文档并不是xml文档。他的结构如下：

- 第一行是DTD声明部分，该声明与xml声明的语法相同。设置`encoding`属性让DTD支持非西欧字符。
- 0到多个注释部分，DTD注释与xml注释的语法完全相同。
- 0到多个<!ELEMENT...>定义，每个<!ELEMENT...>定义一个xml元素。
- 0到多个<!ATTLIST...>定义，每个<!ATTLIST...>为一个xml元素定义一个属性。
- 0到多个<!ENTITY...>定义，每个<!ENTITY...>定义一个xml实体。
- 0到多个<!NOTATION...>定义，每个<!NOTATION...>定义一个xml符号。

### 定义元素 ###

ETD：Element Type Definition，元素类型定义
		
		<!ELEMENT 元素名 元素类型>

元素的类型可以是：

- 任意类型。`<!ELEMENT 元素名 ANY>`。 DTD必须定义xml文档中允许出现的所有元素。xml文档中只能出现在DTD中定义过的元素。应尽量避免使用ANY规则来定义xml元素。
- 空元素。`<!ELEMENT 元素名 EMPTY>`。
- 字符串内容。`<!ELEMENT 元素名 (#PCDATA)>`
- 混合内容。`<!ELEMENT 父元素名 (#PCDATA | 子元素1 | 子元素2 ...)*>`。
	- `#PCDATA`必须放在最前面。
	- `#PCDATA`和个子元素之间只能用竖线分隔，不要用逗号，也不要分组。竖线在这里不是表示互斥，而是可以无序，无次数限制出现。
	- 不要在各子元素后添加?, \*, +等表示频率的修饰符。

不管是哪种类型的XML元素（包括空元素），都可以添加任意多个属性，只是添加属性时必须指定属性值。

### 定义子元素 ###

有序的子元素。子元素之间用英文逗号隔开。
互斥的子元素。子元素之间用竖线隔开。
子元素出现的频率：

- `+`：子元素可以出现1次或多次。
- `*`：子元素可以出现0次或多次。
- `?`：子元素可以查询0次或1次。此时外包元素可能出现内容为空（但不是空元素）的元素。
- 无标志：必须出现且仅出现一次。

在DTD中定义无序子元素的方法：先将多个无序子元素定义为一个互斥的元素组，然后再使用`+`或者`*`修饰元素组。

可以使用圆括号组合元素成元素组，此时该元素组可以作为一个单独的元素使用。

### 定义元素属性 ###

		<!ATTLIST 属性所属的元素 属性名 属性类型 [元素对属性的约束] [默认值]>

- 当没有指定`元素对属性的约束`时，等同于`#IMPLIED`，必须指定`默认值`
- 当`元素对属性的约束`是`#REQUIRED`时，不能指定`默认值`。必须为所属元素提供该属性
- 当`元素对属性的约束`是`#IMPLIED`时，不能指定`默认值`。该属性可有可无
- 当`元素对属性的约束`是`#FIXED`时，必须为该属性指定`默认值`，该属性值是固定的，由系统按`默认值`自动添加值，即使用户手动添加，也必须和`默认值`相同

如果没有指定任何约束规则，则定义该属性时应该为其指定默认值。

属性的类型：

- CDATA             ： 字符串数据
- (en1 | en2 | en3) ： 枚举数据
- ID                ： 唯一标识符
- IDREF             ： 唯一标识符引用，属性值必须是一个已有的ID属性值
- IDREFS            ： 多个唯一标识符引用，以空格隔开
- NMTOKEN           ： 字符串数据，只能使用字母，数字，英文下划线，中划线，点号和冒号。
- NMTOKENS          ： 多个NMTOKEN值，以空格隔开
- ENTITY            ： 一个外部实体，例如图片文件
- ENTITIES          ： 多个外部实体，以空格隔开
- NOTATION          ： 在DTD中声明过的符号。尽量避免使用。
- xml:              ： 预定义的xml值
	
### 定义实体 ###
实体相当于字符串类型的具名变量。

		<!ENTITY 实体名 "实体值"> // 定义
		&实体名;                  // 使用，必须以&开始，以;结束
		
#### 参数实体 ####
参数实体只能在DTD文档中使用。必须前向定义，即先定义后使用。

		<!ENTITY % 实体名 "实体值"> // 定义
		%实体名;                    // 使用

#### 外部实体 ####
使用外部文件的内容替代实体名所在的位置。

		<!ENTITY 实体名 SYSTEM "实体值所在文件的URI"> // 定义
		&实体名;                                      // 使用

外部实体对应的文件可以拥有一个文本声明，类似于XML声明，但可以省略version属性，也不需要指定standalone属性。

#### 外部参数实体 ####
使用外部文件的内容替代参数实体名所在的位置。 

		<!ENTITY % 实体名 PUBLIC|SYSTEM [公用实体标识名] "实体值所在文件的URI"> // 定义
		%实体名;                                                                // 使用

### 定义符号 ###

		<!NOTATION notation SYSTEM "value">
		<!NOTATION notation PUBLIC "name" "value">

符号值的类型：

- MIME类型
- 外部程序所在路径

符号的作用：

- 定义未解析实体
- 作为NOTATION类型的属性的值

当外部实体的文件满足以下条件时，该实体是可解析的外部实体：

- 外部文件是一个文本文件
- 该文件满足xml要求的结构化文档

XML解析器不能处理的外部实体都是未解析实体，不能直接使用，必须为该类ENTITY或ENTITIES添加NOTATION类型的属性来调用。

		<!ENTITY % 实体名 PUBLIC|SYSTEM [公用实体标识名] "实体值所在文件的URI" NDATA notation_name>

未解析实体ENTITY和ENTITIES类型的属性值只能是未解析实体，也就是说定义这些实体时，必须要指定他们的NOTATION属性值。

NOTATION类型的属性值只能是符号名，并且在定义这些属性时必须用枚举的方法列出该属性所支持的符号值。

		<!ATTLIST 属性所属的元素 属性名 NOTATION (值1 | 值2) 约束 默认值>
		
## chapter 4 XML Schema 基本语法 ##
### XML Schema 根元素 ###
XML Schema 也被称为XML Schema 定义（XML Schema Definition， XSD），其本身也是XML文档，根元素是 <schema.../>

XML Schema 根元素的属性：

- `xmlns[:xxx]="a namespace"` 为XML文档引入语义约束，属性值是引入的语义约束的命名空间，xxx是任意的标识名。
- `targetNamespace="a namespace"` 指定此Schema属于哪个命名空间。
- `xmlns="a namespace"` 指定不需要使用前缀的命名空间，可以直接使用该命名空间内的组件而不需要加前缀。只能有一个xmlns属性。注意：如果`targetNamespace`属性和`xmlns`的属性值不一样，则必须定义一个带前缀的`xmlns`属性指向`targetNamespace`，并在每个新定义的组件前加上该前缀。
- `elementFormDefault="qualified | unqualified"` 指定XML文档使用该Schema中定义的局部元素时是否必须使用命名空间限定。
- `attributeFormDefault="qualified | unqualified"` 指定XML文档使用该Schema中定义的局部属性时是否必须使用命名空间限定。

### 在XML中引用无命名空间的Schema ###
需要在根元素中加入以下两个属性值：

- `xmlns:xsi:` 该属性值总是"http://www.w3.org/2001/XMLSchema-instance"
- `xsi:noNamespaceSchemaLocation` 指定XML Schema文件的URI，既可以是URL地址，也可以是本地磁盘的相对路径。

### XML中引用有命名空间的Schema ###

- 每引入一个有命名空间的XML Schema就在XML文档的根元素里增加一个`xmlns[:xxx]`属性，注意只能有一个不带前缀的`xmlns`属性。
- 如果XML根元素中已有`xsi:schemaLocation`属性，则在该属性值后为该XML Schema追加一项，追加项保持 `schemaNamespace schemaURI` 的格式。如果XML根元素中还没有`xsi:schemaLocation`属性，则为其增加该属性，并设置属性值为`schemaNamespace schemaURI`。

一份XML文档中可以引入无数有命名空间的XML Schema，但最多只能引入一份无命名空间的XML Schema以及一份没有前缀的有命名空间的Schema。。

### Schema中的注释 ###
除了传统的`<!-- -->`注释方式，也可以使用`<annotation.../>`添加注释。`<annotation.../>`元素通常放在各种Schema组件定义的开始部分，用于说明该Schema组件的作用。每份Schema文档所包含的第一个元素通常也是`<annotation.../>`，用于对其进行额外说明。

`<annotation.../>`还可以使用以下2个子元素

- `<documentation.../>`: 放置适合人阅读的信息。
- `<appinfo.../>`: 放置针对其他应用程序的信息。

`<annotation.../>`元素里可以出现任意多个`<documentation.../>`子元素，也可以出现任意多个`<appinfo.../>`子元素，而且没有任何顺序要求。

### Schema的数据类型 ###

- 简单类型：可以作为XML元素的类型，也可以作为XML属性的类型。
- 复杂类型：只能作为XML元素的类型。

Schema派生的方式：

- 限制：使用`<restriction.../>`元素为原有类型增加一个或多个额外的约束。
- 列表：使用`<list.../>`定义。
- 联合：使用`<union.../>`

内建基本类型，內建派生类型和用户通过限制派生出来的类型都只能包含单个值组件，因此这些数据类型统称为原子类型。內建派生类型中没哟包含联合类型。

### Schema内置类型 ###

内置类型           | 示例                                                 | 备注
---                | ---                                                  | ---
string             | Confirm this is electric                             |
normalizedString   | Confirm this is electric                             | 备注2
token              | Confirm this is electric                             | 备注4
base64Binary       | GpM7                                                 |
hexBinary          | 0FB7                                                 |
integer            | ...-1,0,1,...                                        | 备注2
positiveInteger    | 1,2,...                                              | 备注2
negativeInteger    | ...-2,-1                                             | 备注2
nonNegativeInteger | 0,1,2,...                                            | 备注2
nonPositiveInteger | ...-2,-1,0                                           | 备注2
long               | -9223372036854775808,..-1,0,1,...9223372036854775807 | 备注2
unsignedLong       | 0,1,...18446744073709551615                          | 备注2
int                | -2147483648,...-1,0,1,...2147483647                  | 备注2
unsignedInt        | 0,1,...4294967295                                    | 备注2
short              | -21768...-1,0,1,...32767                             | 备注2
unsignedShort      | 0,1,...65535                                         | 备注2
byte               | -128...-1,0,1,...127                                 | 备注2
unsignedByte       | 0,1,...255                                           | 备注2
decimal            | -1.23,0,123.4,1000.00                                | 备注2
float              | -INF,-1E4a,-0.0,12.78E-2,12,INF,NaN                  | 等同于单精度32位浮点数，NaN代表非数，备注2
double             | -INF,-1E4a,-0.0,12.78E-2,12,INF,NaN                  | 等同于双精度64位浮点数，NaN代表非数，备注2
boolean            | true,false,0,1                                       |
duration           | P1Y2M3DT10H30M12.3S                                  | 1年2个月3天外加10小时30分钟12.3秒
dateTime           | 1999-05-31-T13:20:00.000-05:00                       | 备注2
date               | 1999-05-31                                           | 备注2
time               | 13:20.00.000,13:20:00.000-05:00                      | 备注2
gYear              | 1999                                                 | 备注2,5
gYearMonth         | feb-99                                               | 1999年2月，不限定具体哪一天。备注2,5
gMonth             | --05--                                               | 5月，备注2,5
gMonthDay          | --05-31                                              | 5月31日，不限定具体哪一年。备注2,5
gDay               | --31                                                 | 31日，不限定具体何年何月。备注2,5
Name               | shipTo                                               | XML1.0中的Name类型
QName              | po:USAddress                                         | XML命名空间的QName类型
NCName             | USAddress                                            | XML命名空间的NCName，例如一个不带命名空间前缀的QName
anyURI             | http://www.example.com
language           | en-GB,en-US,fr                                       | XML1.0中定义的合法语言代码
ID                 |                                                      | XML1.0中定义的ID属性类型。备注1
IDREF              |                                                      | XML1.0中定义的IDREF属性类型。备注1
IDREFS             |                                                      | XML1.0中定义的IDREFS属性类型。备注1
ENTITY             |                                                      | XML1.0中定义的ENTITY属性类型。备注1
ENTITIES           |                                                      | XML1.0中定义的ENTITIES属性类型。备注1
NOTATION           |                                                      | XML1.0中定义的NOTATION属性类型。备注1
NMTOKEN            | US,Bresil                                            | XML1.0中定义的NMTOKEN属性类型。备注1
NMTOKENS           | US UK,Bresil Canada Mexique                          | XML1.0中定义的NMTOKENS属性类型,即以一个空格隔开的NMTOKEN列表。备注1


- 备注1：为了在XML Schema和XML1.0 DTD之间保持良好的兼容性，`ID`，`IDREF`，`IDREFS`，`ENTITY`，`ENTITIES`，`NOTATION`，`NMTOKEN`和`NMTOKENS`等简单类型只能用于定义XML属性。
- 备注2：这种类型的值有多重表示形式。例如100和1.0E2都是有效的`float`类型值，都代表“100”
- 备注3：在Schema处理前，`normalizedString`的值所包含的换行，制表符和回车符都将被当成空白处理
- 备注4：对token而言，会自动删除字符串前后的空白，字符串中间包含的多个连续的空白会被压缩成单个空白。
- 备注5：前缀`g`表示Gregorian时间。

#### 字符串及相关类型 ####

- `string`：保留所有字符串内容，包括空白。
- `normalizedString`：将字符串内容中包含的换行，制表符和回车符都替换成空白。
- `token`：将字符串内容中包含的换行，制表符和回车符都替换成空白，删除字符串前后的空白，中间的空白压缩成单个空白。
- `Name`：字符串内容是一个合法的XML标签名，由字母，数字，下划线，中划线，冒号和点号组成，且不能以数字，中划线或点号开头。
- `NCName`：字符串内容是一个不带命名空间前缀的XML标签名。与Name类型的区别在于，NCName不能包含冒号。
- `QName`：字符串内容是一个带命名空间前缀的XML标签名，但他允许省略命名空间前缀，如果省略了之后，QName类型的值不能以冒号开头。如果使用了前缀，该前缀必须有相对应的命名空间。

#### 数值类型 ####
XML Schema里的float类型的值无须添加f或F后缀。当在XML中输入5.6时，既可以代表float类型，也可以代表double类型的值。

float和double类型可以有以下几个特殊值：

- -INF
- INF
- NaN
- +0
- -0

正零大于负零，NaN大于所有数值，INF大于其他所有浮点数

decimal类型类似Java中的BigDecimal类，表示精确小数。

- decimal更精确，可保证18位有效小数。
- decimal不支持使用科学计数法。
- decimal不支持-INF，INF和NaN等特殊值。

Schema中integer代表任意大的整数，int代表32位的有符号整数。

数据类型           | 说明             | 最小值 | 最大值
---                | ---              | ---    |
integer            | 无限制整数类型   | 无限制 | 无限制
nonNegativeInteger | 无限制的非负整数 | 0      | 无限制
nonPositiveInteger | 无限制的非正整数 | 无限制 | 0
long               | 64位的有符号整数 | -2^63  | 2^63 - 1
positiveInteger    | 无限制的正整数   | 1      | 无限制
negativeInteger    | 无限制的负整数   | 无限制 | -1
unsignedLong       | 64位的无符号整数 | 0      | 2^64 - 1
int                | 32位的有符号整数 | -2^31  | 2^31 - 1
unsignedInt        | 32位的无符号整数 | 0      | 2^32 - 1
short              | 16位的有符号整数 | -2^15  | 2^15 - 1
unsignedShort      | 16位的无符号整数 | 0      | 2^16 - 1
byte               | 8位的有符号整数  | -2^7   | 2^7 - 1
unsignedByte       | 8位的无符号整数  | 0      | 2^8 - 1

#### 日期，时间类型 ####

| 数据类型   | 格式                     | 说明                                                                                                                              |
| ---        | ---                      | ---                                                                                                                               |
| date       | YYYY-MM-DD               | 日期                                                                                                                              |
| time       | hh:mm:ss.sss             | 时间，最后的sss表示毫秒数                                                                                                         |
| dateTime   | YYYY-MM-DDThh:mm:ss.ssss | 日期时间，格式字符串中的T是必需的，是日期和时间的分隔符                                                                           |
| gYear      | YYYY                     | 年                                                                                                                                |
| gYearMonth | YYYY-MM                  | 年月，MM不能指定13                                                                                                                |
| gMonth     | --MM                     | 月，格式字符串中前面两个中划线是必需的                                                                                            |
| gMonthDay  | --MM-DD                  | 月日，格式字符串中前面两个中划线是必需的                                                                                          |
| gDay       | ---DD                    | 日，格式字符串中前面3个中划线是必需的                                                                                             |
| duration   | PnYnMnDTnHnMnS           | 格式字符串中的P是固定的，Y，M，D，H，M，S分别表示年，月，日，时，分，秒，其中Y，M，D，H，M前的n必须是整数，S前的n可以有小数部分。如果使用了H，M，S，则必须使用T分隔符，即使没有使用Y，M，D。

备注：上面列出的前8个数据类型中的Y，M，D，h，m，s分别代表年，月，日，时，分，秒，都可以替换为一个有效的整数，如为MM指定值时可以指定01，12，但不能指定13。只有毫秒数sss既可以是1位的整数，也可以是3位的整数，年份的值是长度小于等于4位的整数（不够4位左边补0），月，日，时，分，秒的值必须是2位的整数（不够在左边补0）。前8个数据类型的值之后可以添加Z表示UTC时间。前5个数据类型的值之前可以添加负号表示公元前。

#### boolean 类型 ####
boolean类型只能接受true，false，0或者1

#### anyURI 类型 ####
任何合法的URI值

#### 二进制数据 ####

- hexBinary： 0~9，a~f，A~F，长度必须是偶数。
- base64Binary：0~9，a~z，A~Z，长度必须是4的倍数。

### 使用限制派生新类型 ###
使用`<simpleType.../>`定义新的简单类型。使用`<complexType.../>`定义复杂类型。其属性如下：

- `id`：指定`<simpleType.../>`和`<complexType.../>`元素的唯一标识。
- `name`：新数据类型的名称。


使用`<restriction.../>`在基类型上添加限制从而产生新的类型。

- `id`：该`<restriction.../>`元素的唯一标识。
- `base`：指定该限制的基类型。

限制约束的种类：

- 枚举约束
	- `enumeration`：元素或者属性的值必须是枚举值中的一个。
- 精度约束
	- `fractionDigits`：对于任意精度的十进制书起作用，用于定义小数点后的最大位数。约束`decimal`派生出来的非`decimal`类型，如`integer`时，约束值只能是0.
	- `totalDigits`：`decimal`及其派生类型的数值最多能有几位数（包括整数和小数部分）。如果与`fractionDigits`同时使用，则`totalDigits`的值必须大于等于`fractionDigits`的值。
- 长度约束。约束基于`string`的数据类型，`QName`，`anyURI`和二进制数据的字符串的长度，还可以用于约束列表类型列表项的数量。
	- `length`：元素或者属性值的字符长度。
	- `minLength`：字符串的最小长度。
	- `maxLength`：字符串的最大长度。
- 范围约束
	- `minExclusive`：元素或属性的下限值（不包括）。
	- `maxExclusive`：元素或属性的上限值（不包括）。必须大于minExclusive的值。
	- `minInclusive`：元素或属性的下限值（包括）。
	- `maxInclusive`：元素或属性的上限值（包括）。必须大于minInclusive的值。
- 正则表达式约束
	- `pattern`：数据类型的值必须匹配的正则表达式。
- 空白处理。
	- `whiteSpace`：字符串中的空白的处理方式。可以是：
		- `preserve`：保留字符串中的空白。
		- `replace`：将所有的制表符，换行符和回车符用空格代替。
		- `collapse`：先执行`replace`，再删除开头和结尾的空格，并将中间的空格压缩成一个。对除`string`和`normalizedString`两种数据类型之外的数据类型添加该约束时，约束值只能是`collapse`。

#### 指定基类型的两种方式 ####

- 使用`<restriction.../>`元素的`base`属性指定基类型
- 在`<restriction.../>`元素内部添加`<simpleType.../>`子元素作为基类型（不常用）
	
#### 指定类型的两种方式 ####

- 使用元素或者属性的Type属性指定他们的类型。
- 使用`<simpleType.../>`或者`<complexType.../>`子元素指定元素或属性的类型。

在XML Schema的根元素下定义的任何元素都可以作为XML文档的根元素使用。

- 全局的有名字的数据类型：`<simpleType.../>`和`<complexType.../>`元素直接作为`<schema.../>`元素的子元素使用，此时需要为这两个元素指定他们的`name`属性，其值就是新定义的数据类型的名称。
- 局部的匿名数据类型：`<simpleType.../>`和`<complexType.../>`作为`<element.../>`，`<attribute.../>`，`<restriction.../>`元素的子元素使用，其作用域仅限于所处的上级元素内。

### 使用`<list.../>`派生列表类型 ###

列表类型的值以空白作为分隔符。对多个空格的处理于token类型相同。

指定列表内部数据类型的方式也有两种：

- 为`<list.../>`元素的`itemType`属性指定列表元素使用已定义的全局数据类型。
- 为`<list.../>`元素增加一个`<simpleType.../>`子元素来使用这个新定义的局部数据类型。

列表类型可以使用如下限制约束：

- 长度约束：`length`，`minLength`，`maxLength`
- 枚举约束：`enumeration`
- 正则表达式约束：`pattern`
- 空白处理：`whiteSpace`。其值只能是`collapse`。

**对列表类型使用`enumeration`和`pattern`约束时，是对列表内容的整体（多个列表项和空格组成的整体）起作用，而不是对单个的列表元素起作用。**

### 使用`<union.../>`派生联合类型 ###
使用`<union.../>`元素创建联合类型时，需要指定一个到多个简单类型，为`<union.../>`指定类型有两种方式：

- 为`<union.../>`元素的`memberTypes`属性指定一个到多个简单类型，多个简单类型之间以空格隔开。
- 为`<union.../>`元素增加一个到多个`<simpleType.../>`子元素，每个`<simpleType.../>`子元素指定一个简单类型。

联合类型的值可以是任意一种成员类型的值。

联合类型可以使用枚举约束`enumeration`和正则表达式约束`pattern`。也是对整个联合类型的值起作用。

- 联合类型的成员类型可以是原子类型，列表类型，也可以是联合类型。
- 列表类型的元素的类型可以是原子类型，联合类型，但不可以是列表类型，也不可以是任何含有列表类型的混合类型。

### 阻止派生新的简单类型 ###

使用`<simpleType.../>`元素指定`final`属性来限制派生新的类型:

- `#all`：限制该类型以任何形式派生新的类型。
- `restriction`，`list`，`union`的组合
- ""：默认方式

可以为Schema文档的根元素`<schema.../>`指定`finalDefault`属性，将对Schema中所有的类型起作用。如果既没有指定`<schema.../>`的`finalDefault`属性，也没有指定`<simpleType.../>`的`final`属性值，则默认不限制任何派生方式。

Schema还允许为任何约束指定`fixed`属性，属性的值只能是`true`或`false`。在使用一个已有类型派生新的类型时，如果新类型添加了和原类型相同的约束，且约束名相同，则新的约束值会覆盖原有的约束值。但如果原类型对应约束指定了`fixed="true"`，则不能被覆盖。

### 合并多个Schema ###

#### 使用include元素 ####

- `<include.../>`元素必须作为Schema文档的根元素`<schema.../>`的子元素。
- `<include.../>`元素必须放在`<schema.../>`元素的开头，只有`<import.../>`，`<redefine.../>`和`<annotation.../>`元素可以放在`<include.../>`元素之前。
- 使用`<include.../>`元素包含的Schema要么没有目标命名空间，要么其目标命名空间与当前Schema的目标命名空间相同。也就是说，使用`<include.../>`元素包含进来的Schema将不再保留他本身的命名空间，被包含Schema所定义的全部组件将放在当前Schema的命名空间下。

`<include.../>`有2个属性：

- `id`：`<include.../>`元素的唯一标识，通常无须指定。
- `schemaLocation`：必填。`<include.../>`元素包含的Schema的位置，可以是相对或绝对位置。

#### 使用redefine元素 ####
`<redefine.../>`元素是`<include.../>`元素的增强版。允许当前Schema重定义被包含Schema中的Schema组件，包括重定义类型，元素组和属性组等。

重定义组件是有以下3个要求：

- 重定义的组件必须是被redefine包含进来的Schema里已有的组件。
- 重定义的组件只能基于被包含Schema里已有的组件增加限制(使用`<restriction.../>`）或增加扩展（使用`<extension.../>`）。
- 如果使用增加限制的方式，则`<restriction.../>`元素里所包含的约束不能违反原类型里已有的约束。

#### 使用import元素 ####

- `<import.../>`元素必须作为Schema文档的根元素`<schema.../>`的子元素。
- `<import.../>`元素必须放在`<schema.../>`元素的开头，只有`<include.../>`，`<redefine.../>`和`<annotation.../>`元素可以放在`<import.../>`元素之前。
- 使用`<import.../>`元素包含的Schema要么没有目标命名空间，要么其目标命名空间与当前Schema的目标命名空间不同，并且不能同时没有目标命名空间。也就是说，使用`<import.../>`元素包含进来的Schema与当前Schema的目标命名空间绝对不能相同。使用被导入的Schema的组件时必须带有前缀作为限定，除非他没有命名空间。

import元素的3个属性：

- `id`：`<import.../>`元素的唯一标识，通常无须指定。
- `schemaLocation`：指定该`<import.../>`元素包含的Schema的位置，既可以是相对位置，也可以是绝对位置。
- `namespace`：指定被导入Schema的目标命名空间，与当前Schema根元素中指定使用的命名空间相对应。如果被导入Schema没有目标命名空间，则该属性可以省略。

## Chapter 5 XML Schema高级知识 ##

### 使用`anyType`定义任意类型 ###

`anyType`是所有简单类型和复杂类型的基类型，通常用于派生新的类型，而不是直接用来定义元素。

### 定义复杂类型 ###

复杂类型使用`<complexType.../>`元素定义，只适用于定义元素（也可以使用简单类型），元素的类型只能是简单类型。

简单类型的元素必须满足：

- 元素内容是简单类型值；
- 元素不包含属性。

复杂类型分为以下几种：

- 元素内容是简单类型值，但元素包含属性，称为包含简单内容的复杂类型，通过`<simpleContent.../>`子元素定义；
- 包含子元素的元素，空元素或混合内容的元素，不管是否包含属性，都是复杂类型，称为包含复杂内容的复杂类型，通过`<complexContent.../>`定义。

#### 定义复杂类型的方式 ####

包含简单内容的复杂类型使用`<simpleContent.../>`子元素定义，内部有且仅有一个以下子元素：

- `<restriction.../>`：限制已有类型从而派生新的复杂类型
- `<extension.../>`：扩展已有类型从而派生新的复杂类型

使用这两个子元素时必须指定它们的基类型，这个基类型必须是以下二者之一：

- 简单类型
- 包含简单内容的复杂类型

#### 扩展简单类型 ####

使用`<extension.../>`元素扩展简单类型包括添加属性或属性组。

#### 包含属性的两种方式 ####

- 局部属性：类似局部变量，直接把属性放在`<complexType.../>`内定义。基本属性只能属于当前复杂类型；
- 全局属性：类似全局变量，把属性作为`<schema.../>`的子元素定义。通过为`<attribute.../>`元素指定`ref`属性值建立全局属性与复杂类型间的关联。

使用`<attribute.../>`元素定义属性是可以指定以下两个常用属性：

- `fixed`：为该属性指定一个固定值；
- `default`：为该属性指定一个默认值。

这两个属性互斥，不能同时出现。

`<attribute.../>`的`ref`属性不能和`name`，`type`属性（这两个属性用于定义属性）同时使用。

`<attribute.../>`的`use`属性只能在以下情况才能使用：

- `<attribute.../>`元素里指定了`ref`属性；
- 使用`<attribute.../>`元素定义局部属性时。

`use`属性用于指定该复杂类型对该属性的要求，支持如下几个属性值：

- `optional`：指定该属性是可选的，也是该属性的默认值；
- `prohibited`：该属性是被禁止的，不能出现；
- `required`：该属性是必需的。

如果定义某个属性的时候通过`default`指定了默认值，则使用该属性时的`use`属性只能是`optional`。

#### 使用派生类型的另一种方式 ####

如果一个元素`element`的类型`typeA`派生了新的类型`typeA1`，那么该元素将变成2个“虚拟”的元素，一个元素的类型是`typeA`，另一个则是`typeA1`。在使用该元素时，可以通过它的`xsi:type`属性来指定该元素的实际类型。

#### 限制包含简单内容的复杂类型 ####

3种方法来限制包含简单内容的复杂类型：

- 为元素内容添加进一步的约束；
- 为元素的属性添加进一步的约束；
- 删除某些属性。

#### 限制`anyType`派生新类型 ####

通过限制`anyType`派生的新类型是包含复杂内容的复杂类型。

定义元素出现的规则：

- `<sequence.../>`：子元素必须按定义的顺序出现；
- `<choice.../>`：子元素只能出现其中之一；
- `<all.../>`：子元素能以任意顺序出现。

schema约定：如果某个复杂类型是由限制`anyType`派生出来的，纳闷在定义该复杂类型时可以省略`<complexContent.../>`和`<restriction.../>`元素，直接在`<complexType.../>`元素内使用`<sequence.../>`，`<choice.../>`，`<all.../>`和`<attribute.../>`来定义元素和属性。

`<all.../>`元素的使用限制：

- `<all.../>`元素内包含的子元素不能重复出现，最多只能出现一次；
- `<all.../>`元素不能与`<sequence.../>`和`<choice.../>`元素同时出现，而且不能放在`<sequence.../>`和`<choice.../>`元素内部使用。通常只能作为`<complexContent.../>`或`<complexType.../>`元素的顶级子元素使用。

<choice.../>和<sequence.../>元素包含的<element.../>元素都可以指定maxOccurs属性，用于指定该元素允许出现的次数；<all.../>元素虽然也可以指定maxOccurs属性，但其属性值只能是0或1.

#### 包含子元素的两种方式 ####

shema中定义元素有2中方式：

- 全局元素：将`<element.../>`元素放在<schema.../>元素的根元素下定义；
- 局部元素：将`<element.../>`元素放在`<sequence.../>`，`<choice.../>`或`<all.../>`里定义。

`<element.../>`元素有三个常用属性：

- `fixed`：为该元素指定固定值；
- `default`：为该元素指定默认值；
- `nillable`：true/false。指定是否可以将显式的零值分配给该元素，该属性值只对元素内容有效，对元素属性无效，默认值false。

前两者不能同时在`<element.../>`元素中使用。

`<element.../>`元素还可以添加`ref`属性，以引用一个已有的全局元素。和`<attribute.../>`元素类似，该属性也不能和定义元素的`name`，`type`属性同时使用。

`<element.../>`的`minOccurs`和`maxOccurs`属性只有在下列情况下才能使用：

- `<element.../>`元素指定了ref属性
- 使用`<element.../>`元素定义局部元素

这两个属性值分别用于指定该元素允许出现的最小次数和最大次数，可以使任何非零整数或者`unbounded`（不限制次数），但`minOccurs`的值不能大于`maxOccurs`的值。如果没有显式指定，则其默认值都是1。`<sequence.../>`，`<choice.../>`，`<all.../>`都包含这两个属性。例如，当需要指定无序子元素时，可以通过为`<choice.../>`元素添加`maxOccurs`属性来实现。

#### 空元素类型 ####

定义空元素类型有2中方式：

- 扩展长度为0的字符串。如果该元素不需要包含属性，可以直接使用长度为0的字符串类型定义该元素。
- （推荐）限制`anyType`。限制`anyType`时不定义任何子元素，之定义所需属性即可。

#### 混合内容类型 ####

定义混合内容类型：为`<complexType.../>`元素添加`mixed="true"`。

### 复杂类型的进一步派生 ###

#### 限制空元素类型 ####

两种方式来限制空元素类型：

- 对指定属性增加进一步的约束；
- 删除某个属性。

通过限制空元素类型派生的类型还是空元素类型，只不过新类型要么具有更少的属性，要么其属性具有更严格的语义约束。

#### 扩展空元素类型 ####

- 为原有类型添加新属性：派生出来的新类型仍然是空元素类型；
- 为原有类型增加子元素：派生出来的新类型是包含子元素的类型；
- 为原有类型增加`mixed="true"`：派生出来的新类型是混合内容类型。

#### 限制包含子元素的类型 ####

- 对指定属性的类型增加进一步约束；
- 对指定子元素的类型增加进一步约束；
- 删除指定属性；
- 删除指定元素。

通过限制来派生新类型时，对基类型中的子元素和属性的处理方式不一样：

- 子元素：默认删除基类型中的所有子元素定义，所有必须根据需要重新定义；
- 属性：默认保留基类型中的所有属性定义，如果不需要某些属性，必须在定义该属性时使用`use="prohibited"`。

派生类型中为子元素和属性的类型增加进一步约束时，新增的约束必须在基类型的约束范围之内。例如，对于删除子元素和属性而言，删除子元素的实质是将该元素的`maxOccurs`和`minOccurs`属性同时设为0，而删除属性的实质是将`use`属性设为`prohibited`。因此如果希望删除某个子元素，则基类型中定义该子元素时必须指定`minOccurs="0"`；而如果希望删除某个属性，则基类型中定义该属性时一定不能指定`use="required"`。

#### 扩展包含子元素的类型 ####

- 为基类型增加新的子元素；
- 为基类型增加新的属性。

扩展包含子元素的类型所派生出来的类型依然不可以是混合内容类型，也就是说不能为派生出的复杂类型添加`mixed="true"`。

当为基类型添加新的子元素时，schema使用`<sequence.../>`元素来组合基类型中原有的子元素组和新增的子元素组。如果基类型使用`<all.../>`元素定义了子元素，则通过扩展派生出来的新类型无法添加新的子元素；即使基类型中没有使用`<all.../>`元素定义子元素，在通过扩展派生新类型时也不能添加由`<all.../>`元素包含的子元素。

#### 限制混合内容类型 ####

通过限制混合内容类型派生出的新类型如果没有指定`mixed="true"`，则此新类型不再是混合内容类型。

#### 扩展混合内容类型 ####

通过扩展混合内容类型派生出来的新类型必须是混合内容类型，即必须保留`mixed="true"`。

### 阻止派生新的类型 ###

如果需要阻止派生类型的再次派生，必须在定义该类型的`<complexType.../>`元素时指定final属性：

- `#all`：阻止以任何方式来以该类型为基类型派生新的类型；
- `extension`：阻止以扩展的方式来以该类型为基类型派生新的类型；
- `restriction`：阻止以限制的方式来以该类型为基类型派生新的类型；
- `extension`和`restriction`的组合：相当于使用`#all`。

如果定义`<complexType.../>`时没有指定`final`属性，则其默认值为`<schema.../>`元素的`finalDefault`属性值。

- 以简单类型为基类型派生的方式有3种：限制（restriction），列表（list）和联合（union）。
- 以复杂类型为基类型派生的方式只有2种：限制（restriction）和扩展（extension）。

### 通配符 ###

#### 元素通配符 ####

schema使用`<any.../>`作为元素通配符，可以代表任何元素，接受以下属性：

- id：该元素的唯一标识，通常无须指定；
- maxOccurs：该通配符所代表的元素最多可以出现的次数。可以是任意非零整数或`"unbounded"`字符串；
- minOccurs：该通配符所代表的元素最少可以出现的次数。可以是任意非零整数；
- namespace：可代替的元素必须来自哪个空间。
	- ##any：来自任何命名空间的元素都可以代替该元素通配符；
	- ##other：来自该元素的父元素的目标命名空间以外的其他命名空间的元素才可以代替该元素通配符；
	- ##local：无命名空间限定的元素可代替该元素通配符；
	- ##targetNamespace：来自该元素的父元素的目标命名空间的元素才可以代替该元素通配符；
	- 命名空间URI：自由来自该命名空间的元素才能代替该元素通配符；
	- 上列多个值的列表：值列表中的任意一个所对应命名空间的元素都可以。
- processContents：应用程序或XML处理器如何对替换元素进行验证。如果没有指定该属性，则默认为`strict`。
	- strict：处理器必须获得所需命名空间（由namespace指定）对应的schema，并验证来自该命名空间的所有元素；
	- lax：处理器会尝试获得所需命名空间（由namespace指定）对应的schema，如果获得成功，则验证来自该命名空间的所有元素；如果没有获得，也不会发生错误；
	- skip：处理器不会取获取所需命名空间，也不会进行任何验证。但替换元素依然必须来自namespace属性指定的命名空间。

#### 属性通配符 ####

schema使用`<anyAttribute.../>`元素定义属性通配符，因为同一个元素不能同时包含同名的属性，所以`<anyAttribute.../>`元素不能指定`minOccurs`和`maxOccurs`属性。它的`id`，`namespace`和`processContents`属性和`<any.../>`元素的相应属性的意义完全相同。

### 元素替换 ###

通过为一个元素添加`substitutionGroup`属性让它可以替换另一个元素，被替换的元素的名字就是该属性的值。

需要注意：

- 替换元素和被替换元素都必须以全局元素的形式来声明；
- 替换元素和被替换元素要么有相同的数据类型，要么替换元素类型是被替换元素类型的派生类型。

#### 阻止自己被替换 ####

为`<element.../>`元素添加`final`属性来控制该元素被替换：

- `#all`：绝不会被其他元素替换；
- `extension`：阻止通过扩展该元素类型派生出来的新类型的元素替换自己；
- `restriction`：阻止通过限制该元素类型派生出来的新类型的元素替换自己；
- `extension`和`restriction`的组合：阻止以这两种方式派生出来的新类型的元素替换自己。

`<element.../>`元素可以把`final`属性替换为`block`属性，二者可接受的值基本一样，区别在于`block`属性的阻止功能仅对XML文档有效，对`Schema`则无效，而`final`属性对两者都有效。

#### 阻止指定派生类型的替换 ####

在为`<complexType.../>`元素指定`block`属性后，该`block`属性的值将对该复杂类型生效，即该类型的所有元素都不会被替换。这里不能用`final`属性是因为`<complexType.../>`元素的`final`属性用于指定该类型元素是否能被派生。


### 抽象元素和抽象类型 ###

schema允许定义元素或者类型时指定`abstract="true"`，表示这是抽象元素或抽象类型，不能直接在XML文档中使用，必须使用替换元素来替换抽象元素，用派生类型替换抽象类型。如果需要在XML文档中使用抽象类型的元素，必须为该元素增加`xsi:type`属性，以指定它是抽象类型的某个具体派生类型的元素。

### 一致性约束 ###

- key约束：相当于数据库中的主键约束，要求指定内容必须存在且唯一；
- keyref约束：相当于数据库中外键约束，要求制定内容的值必须引用另一个key约束或unique约束。用于建立2个数据项之间的引用关系；
- unique约束：相当于数据库中的唯一约束，要求指定内容必须唯一，并可以不存在，但最多只能有一个空值。

这三个一致性约束只能在<element.../>元素中定义，且必须放在<element.../>元素的最后定义。

在约束的内部使用如下两个子元素指定该约束应用的对象：

- `<selector.../>`：需要指定一个xpath属性，其值是一个XPath表达式，用来确定一个元素范围。在一次约束定义中，`<selector.../>`元素必须出现一次，但也只能出现一次。
- `<field.../>`：需要指定一个xpath属性，其值也是一个XPath表达式。在一次约束定义中，`<field.../>`至少需要出现一次，但也可以出现多次。

语义说明：在<selector>元素的XPath表达式所表示的范围内，<field>元素的XPath表达式所表示的内容必须遵守一致性约束。如果同时指定了多个<field>子元素，则它们的XPath表达式所表示的内容的组合必须遵守一致性约束，但单个XPath表达式所表示的内容无须遵守一致性约束。类似于数据库中的数据表和数据列的关系。

### 元素组和属性组 ###

schema使用`<group.../>`元素定义和使用元素组，使用`<attributeGroup.../>`元素定义和使用属性组。

元素组内部仍然使用`<sequence.../>`，`<choice.../>`和`<all.../>`来管理元素之间的关系。使用元素组的语法：

		<xs:group ref="分组名" minOccurs="最少出现数" maxOccurs="最多出现数"/>

定义属性组的语法：

		<xs:attributeGroup name="属性组名">
			<xs:attribue name=.../>
			...
		</xs:attributeGroup>

使用属性组的语法：

		<xs:attributeGroup ref="属性组名"/>

### 定义符号 ###

schema使用<notation.../>定义符号，接受如下属性：

- id：该符号的唯一标识，通常无须指定；
- name：该符号的名称。必填属性，而且在整个schema内必须是唯一的；
- public：该符号所标识数据的外部格式或对应处理程序。必填属性。
- system：该符号所标识数据的外部格式或对应处理程序。可选属性。
































